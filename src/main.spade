use std::ops::div_pow2;

enum Output<T> {
    UpdateMode,
    FrameInv{val: bool},
    AllClear,
    Dummy,
    Address{b: bool},
    Pixel{p: T},
    // Chip select should be high but sclk should be masked
    CsHigh,
    // Chip select should be low but sclk should be masked
    CsLow
}

struct DisplayGenOutput {
    sclk: bool,
    o: Output<(int<10>, int<9>)>
}

/// Generates the base otuput signals which should then be converted
/// to contain the graphics and passed to the output translator
entity display_gen(clk: clk, rst: bool, t: Timing) -> DisplayGenOutput {
    let Clk$(sclk, sclk_falling_edge) = inst clk_gen(clk, rst, t);

    let state = inst display_fsm$(clk, rst, sclk_falling_edge, t);

    DisplayGenOutput(sclk, display_output(state))
}

struct OutputPins {
    sclk: bool,
    cs: bool,
    mosi: bool,
}

fn output_translator(o: Output<bool>, sclk: bool) -> OutputPins {
    match o {
        Output::UpdateMode => OutputPins$(sclk, cs: true, mosi: true),
        Output::FrameInv(val) => OutputPins$(sclk, cs: true, mosi: val),
        Output::AllClear => OutputPins$(sclk, cs: true, mosi: false),
        Output::Dummy => OutputPins$(sclk, cs: true, mosi: false),
        Output::Address(val) => OutputPins$(sclk, cs: true, mosi: val),
        Output::Pixel(val) => OutputPins$(sclk, cs: true, mosi: val),
        Output::CsHigh => OutputPins$(sclk: false, cs: true, mosi: false),
        Output::CsLow => OutputPins$(sclk: false, cs: false, mosi: false),
    }
}

// Private stuff

struct Timing {
    us1: int<10>,
    us3: int<10>,
    mhz1: int<10>
}

// Using int<9> to avoid having to worry about negative numbers
enum State {
    CsLow{line: int<9>, duration: int<10>},
    CsHigh{line: int<9>, duration: int<10>},
    Mode{line: int<9>},
    FrameInv{line: int<9>},
    Clear{line: int<9>},
    FirstDummy{line: int<9>, count: int<5>},
    Address{line: int<9>, count: int<5>},
    Data{line: int<9>, x: int<10>},
    EndDummy{line: int<9>, count: int<5>},
    EndCsh{line: int<9>, duration: int<10>},
}


struct Clk {
    sclk: bool,
    sclk_falling_edge: bool
}

entity clk_gen(clk: clk, rst: bool, t: Timing) -> Clk {
    reg(clk) ctr reset(rst: 0) = {
        if ctr == t.mhz1 {
            0
        }
        else {
            trunc(ctr+1)
        }
    };

    Clk$(
        sclk: ctr > (t.mhz1 `div_pow2` 1),
        sclk_falling_edge: ctr == 0
    )
}

entity display_fsm(clk: clk, rst: bool, sclk_falling_edge: bool, t: Timing) -> State {
    reg(clk) state reset(rst: State::CsLow(0, 0)) = match state {
        State::CsLow$(line, duration) => {
            if duration == trunc(t.us1-1) {
                State::CsHigh$(line, duration: 0)
            }
            else {
                State::CsLow$(line, duration: trunc(duration+1))
            }
        },
        State::CsHigh$(line, duration) => {
            if duration == trunc(t.us1-1) {
                if sclk_falling_edge {State::Mode(line)} else {state}
            }
            else {
                State::CsHigh$(line, duration: trunc(duration+1))
            }
        },
        State::Mode(line) =>
            if sclk_falling_edge {State::FrameInv(line)} else {state},
        State::FrameInv(line) =>
            if sclk_falling_edge {State::Clear(line)} else {state},
        State::Clear(line) =>
            if sclk_falling_edge {State::FirstDummy$(line, count: 0)} else {state},
        State::FirstDummy$(line, count) => {
            if sclk_falling_edge {
                if count == 4
                    { State::Address$(line, count: 0) }
                else
                    { State::FirstDummy$(line, count: trunc(count+1)) }
            }
            else {
                state
            }
        },
        State::Address$(line, count) => {
            if sclk_falling_edge {
                if count == 7
                    {State::Data$(line, x: 0)}
                else
                    {State::Address$(line, count: trunc(count + 1))}
            }
            else {
                state
            }
        },
        State::Data$(line, x) => {
            if sclk_falling_edge {
                // TODO: Make configurable?
                if x == 399
                    { State::EndDummy$(line, count: 0) }
                else
                    { State::Data$(line, x: trunc(x+1)) }
            }
            else {
                state
            }
        },
        State::EndDummy$(line, count) => {
            if sclk_falling_edge {
                if count == 15
                    { State::EndCsh$(line, duration: 0) }
                else
                    { State::EndDummy$(line, count: trunc(count+1)) }
            }
            else {
                state
            }
        },
        State::EndCsh$(line, duration) => {
            if duration >= trunc(t.us1 - 1) {
                let new_line = if line == 239 { 0 } else { trunc(line+1) };
                State::CsLow$(line: new_line, duration: 0)
            }
            else {
                State::EndCsh$(line, duration: trunc(duration+1))
            }
        }
    };

    state
}


fn display_output(state: State) -> Output<(int<10>, int<9>)> {
    match state {
        State::CsLow(_, _) => Output::CsLow(),
        State::CsHigh(_, _) => Output::CsHigh(),
        State::Mode(_) => Output::UpdateMode(),
        State::FirstDummy(_, _) => Output::Dummy(),
        State::FrameInv(line) => Output::FrameInv((line & 1) == 1),
        State::Clear(_) => Output::AllClear(),
        State::Address(line, count) => Output::Address(((sext(line) >> count) & 1) == 1),
        State::Data$(line, x) => Output::Pixel((x, line)),
        State::EndDummy(_, _) => Output::Dummy(),
        State::EndCsh(_, _) => Output::CsHigh(),
    }
}
